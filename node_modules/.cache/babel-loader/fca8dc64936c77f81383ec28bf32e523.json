{"ast":null,"code":"import { postErrorToTrackingSheet } from './postDataToTrackingSheet'; // THIS WHOLE FINDDRIVEFOLDERIDS FUNCTION SHOULD BE REFACTORED TO A FETCH FOLDER DATA FUNCTION\n\nexport const findDriveFolderIds = selectionData => {\n  const ACCESS_TOKEN = process.env.REACT_APP_ACCESS_TOKEN;\n  let fileName = `KS_${selectionData.video.mcVodId}_HD.wmv`;\n  let folderName = `${selectionData.reviewer}_QA`;\n  const reviewerIds = {\n    \"Craig_QA\": \"1GRkauySLVv3YDsIvv8jM4fLApCI6YKqW\",\n    \"Junior_QA\": \"1TpVBnxkCQwFIPjq-yQreCGm5oc-fR5o2\",\n    \"Mike_G_QA\": \"1BD6vFptjA0N_oAyvQmShSqVMupWXoZxm\",\n    \"Mike_Berlin_QA\": \"1ZLT3gJAxqq7kMGQO-lTEKOvbmfz8UIfe\",\n    \"Ron_QA\": \"1gY0s29gHOt9qUOBmuX6alUGHVaFQDMqb\",\n    \"Shane_QA\": \"14Ot7H6HKw6pks07oLitQkjb25pJFzc0r\",\n    \"Tim_QA\": \"16XBqeXOWpBsw8AV3gbgMMunWKKjMafNH\"\n  };\n  return dispatch => {\n    fetch(`https://www.googleapis.com/drive/v3/files?corpora=allDrives&includeTeamDriveItems=true&pageSize=1000&supportsAllDrives=true`, {\n      headers: {\n        authorization: `Bearer ${ACCESS_TOKEN}`\n      }\n    }).then(response => response.json()).then(rxData => {\n      let reviewerFolder = rxData.files.find(folder => folder.name === folderName);\n\n      if (!reviewerFolder) {\n        debugger;\n        reviewerFolder = checkNextPageForFolder(rxData.nextPageToken, folderName);\n        debugger;\n      }\n\n      const oldParentFolder = \"1shZeeuZyfUucN8egUBkemkmbexmkjWji\";\n      debugger; // GET FILE IDS OF SELECTED VIDEOS\n\n      if (rxData.files.find(file => file.name === fileName)) {\n        const selectedDriveDataId = rxData.files.find(file => file.name === fileName).id;\n        const dataForUpdate = {\n          fileId: selectedDriveDataId,\n          fileName: fileName,\n          reviewerName: selectionData.reviewer,\n          reviewerFolder: reviewerFolder,\n          parentFolder: oldParentFolder\n        };\n        updateDriveFolders(dataForUpdate);\n      } else {\n        checkNextPageForVideo(rxData.nextPageToken, selectionData, reviewerFolder, oldParentFolder);\n      }\n    });\n  };\n};\nexport const updateDriveFolders = dataForUpdate => {\n  // const movedVideos = []\n  const ACCESS_TOKEN = process.env.REACT_APP_ACCESS_TOKEN;\n  const url = `https://www.googleapis.com/drive/v3/files/${dataForUpdate.fileId}?addParents=${dataForUpdate.reviewerFolder.id}&removeParents=${dataForUpdate.parentFolder}`;\n  debugger;\n  fetch(url, {\n    method: 'PATCH',\n    headers: {\n      authorization: `Bearer ${ACCESS_TOKEN}`\n    }\n  }).then(response => response.json()).then(rxData => {\n    rxData.error ? alert(rxData.error) : alert(`You have moved ${dataForUpdate.fileName}`);\n  });\n};\nexport const checkNextPageForVideo = (nextPageToken, missingProxy, reviewerFolder, oldParentFolder) => {\n  const ACCESS_TOKEN = process.env.REACT_APP_ACCESS_TOKEN;\n  const name = `KS_${missingProxy.video.mcVodId}_HD.wmv`;\n  debugger;\n  fetch(`https://www.googleapis.com/drive/v3/files?corpora=allDrives&includeTeamDriveItems=true&pageSize=1000&pageToken=${nextPageToken}&supportsAllDrives=true`, {\n    headers: {\n      authorization: `Bearer ${ACCESS_TOKEN}`\n    }\n  }).then(reponse => reponse.json()).then(rxData => {\n    if (rxData.error) {\n      alert(`Can Not Find ${name}`); // postErrorToTrackingSheet(missingProxy)\n    } else if (rxData.files.find(file => file.name === name)) {\n      const selectedFileDriveId = rxData.files.find(file => file.name === name).id;\n      const dataForUpdate = {\n        fileId: selectedFileDriveId,\n        fileName: name,\n        reviewerFolder: reviewerFolder,\n        parentFolder: oldParentFolder\n      };\n      updateDriveFolders(dataForUpdate);\n    } else {\n      checkNextPageForVideo(rxData.nextPageToken, missingProxy, reviewerFolder, oldParentFolder);\n    }\n  });\n};\nexport const checkNextPageForFolder = (nextPageToken, folderName) => {\n  const ACCESS_TOKEN = process.env.REACT_APP_ACCESS_TOKEN;\n  let folder;\n  fetch(`https://www.googleapis.com/drive/v3/files?corpora=allDrives&includeTeamDriveItems=true&pageSize=1000&pageToken=${nextPageToken}&supportsAllDrives=true`, {\n    headers: {\n      authorization: `Bearer ${ACCESS_TOKEN}`\n    }\n  }).then(response => response.json()).then(rxData => {\n    debugger;\n\n    if (rxData.error) {\n      // debugger\n      alert(`Can Not Find ${folderName}`);\n    } else if (rxData.files.find(folder => folder.name === folderName)) {\n      folder = rxData.files.find(folder => folder.name === folderName);\n      debugger;\n    } else {\n      // debugger\n      checkNextPageForFolder(rxData.nextPageToken, folderName);\n    }\n  });\n  debugger;\n  return folder;\n};","map":{"version":3,"sources":["/Users/John/Dev/MC/media_ops_control_center/the-mocc-front/src/actions/moveToSelectedDriveFolder.js"],"names":["postErrorToTrackingSheet","findDriveFolderIds","selectionData","ACCESS_TOKEN","process","env","REACT_APP_ACCESS_TOKEN","fileName","video","mcVodId","folderName","reviewer","reviewerIds","dispatch","fetch","headers","authorization","then","response","json","rxData","reviewerFolder","files","find","folder","name","checkNextPageForFolder","nextPageToken","oldParentFolder","file","selectedDriveDataId","id","dataForUpdate","fileId","reviewerName","parentFolder","updateDriveFolders","checkNextPageForVideo","url","method","error","alert","missingProxy","reponse","selectedFileDriveId"],"mappings":"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","sourcesContent":["import { postErrorToTrackingSheet } from './postDataToTrackingSheet'\n// THIS WHOLE FINDDRIVEFOLDERIDS FUNCTION SHOULD BE REFACTORED TO A FETCH FOLDER DATA FUNCTION\nexport const findDriveFolderIds = (selectionData) => {\n    const ACCESS_TOKEN = process.env.REACT_APP_ACCESS_TOKEN\n    let fileName = `KS_${selectionData.video.mcVodId}_HD.wmv`\n    let folderName = `${selectionData.reviewer}_QA`\n    const reviewerIds = {\n        \"Craig_QA\":\"1GRkauySLVv3YDsIvv8jM4fLApCI6YKqW\",\n        \"Junior_QA\": \"1TpVBnxkCQwFIPjq-yQreCGm5oc-fR5o2\",\n        \"Mike_G_QA\": \"1BD6vFptjA0N_oAyvQmShSqVMupWXoZxm\",\n        \"Mike_Berlin_QA\":\"1ZLT3gJAxqq7kMGQO-lTEKOvbmfz8UIfe\",\n        \"Ron_QA\":\"1gY0s29gHOt9qUOBmuX6alUGHVaFQDMqb\",\n        \"Shane_QA\":\"14Ot7H6HKw6pks07oLitQkjb25pJFzc0r\",\n        \"Tim_QA\":\"16XBqeXOWpBsw8AV3gbgMMunWKKjMafNH\"\n    }\n    return (dispatch) => {\n        fetch(`https://www.googleapis.com/drive/v3/files?corpora=allDrives&includeTeamDriveItems=true&pageSize=1000&supportsAllDrives=true`, \n        { \n            headers: {\n                authorization: `Bearer ${ACCESS_TOKEN}`\n            }\n        }).then(response => response.json())\n        .then(rxData => {\n            let reviewerFolder = rxData.files.find(folder => folder.name === folderName)\n            if(!reviewerFolder){\n                debugger\n                reviewerFolder = checkNextPageForFolder(rxData.nextPageToken, folderName)\n                debugger\n            }\n            \n            const oldParentFolder = \"1shZeeuZyfUucN8egUBkemkmbexmkjWji\"\n            debugger\n            // GET FILE IDS OF SELECTED VIDEOS\n            if(rxData.files.find(file => file.name === fileName)){\n                const selectedDriveDataId = rxData.files.find(file => file.name === fileName).id  \n                    const dataForUpdate = {\n                        fileId: selectedDriveDataId,\n                        fileName: fileName,\n                        reviewerName: selectionData.reviewer,\n                        reviewerFolder: reviewerFolder,\n                        parentFolder: oldParentFolder\n                    }\n                    updateDriveFolders(dataForUpdate)\n                           \n            }else{\n                checkNextPageForVideo(rxData.nextPageToken, selectionData, reviewerFolder, oldParentFolder)\n            } \n        })\n    }\n}\n\n\nexport const updateDriveFolders = (dataForUpdate) => {\n    // const movedVideos = []\n    const ACCESS_TOKEN = process.env.REACT_APP_ACCESS_TOKEN\n    const url = `https://www.googleapis.com/drive/v3/files/${dataForUpdate.fileId}?addParents=${dataForUpdate.reviewerFolder.id}&removeParents=${dataForUpdate.parentFolder}`\n    debugger\n    fetch(url, {\n        method: 'PATCH',\n        headers: {\n            authorization: `Bearer ${ACCESS_TOKEN}`\n        }\n    }).then(response => response.json())\n    .then(rxData => {\n        rxData.error ? alert(rxData.error) :alert(`You have moved ${dataForUpdate.fileName}`)\n    })  \n}\n\n\nexport const checkNextPageForVideo = (nextPageToken, missingProxy, reviewerFolder, oldParentFolder) => {\n    const ACCESS_TOKEN = process.env.REACT_APP_ACCESS_TOKEN\n    const name = `KS_${missingProxy.video.mcVodId}_HD.wmv`\n    debugger\n    fetch(`https://www.googleapis.com/drive/v3/files?corpora=allDrives&includeTeamDriveItems=true&pageSize=1000&pageToken=${nextPageToken}&supportsAllDrives=true`, {\n        headers:{\n            authorization: `Bearer ${ACCESS_TOKEN}`\n        }\n    }).then(reponse => reponse.json())\n    .then(rxData => {\n        if(rxData.error){\n            alert(`Can Not Find ${name}`)\n            // postErrorToTrackingSheet(missingProxy)\n        }else if(rxData.files.find(file => file.name === name)){\n            const selectedFileDriveId = rxData.files.find(file => file.name === name).id\n            const dataForUpdate = {\n                fileId: selectedFileDriveId,\n                fileName: name,\n                reviewerFolder: reviewerFolder,\n                parentFolder: oldParentFolder\n            }\n            updateDriveFolders(dataForUpdate)\n             \n        }else{\n            checkNextPageForVideo(rxData.nextPageToken, missingProxy, reviewerFolder, oldParentFolder)\n        }\n    })\n}\n\n\nexport const checkNextPageForFolder = (nextPageToken, folderName) => {\n    const ACCESS_TOKEN = process.env.REACT_APP_ACCESS_TOKEN\n     let folder \n    fetch(`https://www.googleapis.com/drive/v3/files?corpora=allDrives&includeTeamDriveItems=true&pageSize=1000&pageToken=${nextPageToken}&supportsAllDrives=true`, {\n        headers:{\n            authorization: `Bearer ${ACCESS_TOKEN}`\n        }\n    }).then(response => response.json())\n    .then(rxData => {\n        debugger\n        if(rxData.error){\n            // debugger\n            alert(`Can Not Find ${folderName}`)\n        }else if(rxData.files.find(folder => folder.name === folderName)){\n            folder = rxData.files.find(folder => folder.name === folderName)\n            debugger\n        }else{\n            // debugger\n            checkNextPageForFolder(rxData.nextPageToken, folderName)\n        }\n    })\n    debugger\n    return folder\n    \n}\n\n\n\n\n"]},"metadata":{},"sourceType":"module"}